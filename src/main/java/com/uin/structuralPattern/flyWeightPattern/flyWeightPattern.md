# 享元模式

## 概述

当一个软件系统在运行时产生的对象数量太多，将导致运行代价过高，带来系统性能下降等问题。例如，在一个文本字符串中存在很多重复的字符，如果每个字符都用一个单独的对象来表示，将会占用较多的内存空间。

那么，如何去避免系统中出现大量相同或相似的对象，同时又不影响客户端程序通过面向对象的方式对这些对象进行操作？享元模式正为解决这一类问题而诞生。

享元模式通过共享技术实现相同或相似对象的重用。在逻辑上每个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象。这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例。在享元模式中，存储这些共享实例对象的地方称为享元池（Flyweight Pool）。

可以针对每个不同的字符创建一个享元对象，将其放在享元池中，需要时再从享元池取出。

享元模式以共享的方式高效地支持大量细粒度对象的重用。享元对象能做到共享的关键是区分了内部状态（Intrinsic State）和外部状态（Extrinsic State）。下面对享元的内部状态和外部状态进行简单介绍。

1. 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。例如字符的内容，不会随外部环境的变化而变化，无论在任何环境下，字符“a”始终是“a”，都不会变成“b”。
2. 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候，再传入享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。如字符的颜色，可以在不同的地方有不同的颜色，例如有的“a”是红色的，有的“a”是绿色的；字符的大小也是如此，有的“a”是五号字，有的“a”是四号字。而且字符的颜色和大小是两个独立的外部状态，它们可以独立变化，相互之间没有影响，客户端可以在使用时将外部状态注入享元对象中。


## 定义

享元模式（Flyweight Pattern）：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，是一种对象结构型模式。

享元模式结构较为复杂，一般结合工厂模式一起使用。

在享元模式结构图中包含以下4个角色。

1. Flyweight（抽象享元类）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。
2. ConcreteFlyweight（具体享元类）：它实现了抽象享元类，其实例称为享元对象。在具体享元类中为内部状态提供了存储空间。通常，可以结合单例模式来设计具体享元类，为每个具体享元类提供唯一的享元对象。
3. UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类。当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 
4. FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中。享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计。当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例，或者创建一个新的实例（如果不存在的话）并返回新创建的实例，同时将其存储在享元池中。

## 案例

假设我们需要管理大量的文字字符对象，每个字符对象可能会有一些共享的状态，比如字符本身，而每个字符的颜色和字体大小等则是外部状态。

1. 定义享元接口
[Flyweight.java](Flyweight.java)
2. 实现具体享元类
[CharacterFlyweight.java](CharacterFlyweight.java)
3. 创建享元工厂
[FlyweightFactory.java](FlyweightFactory.java)
4. 客户端代码
[Client.java](Client.java)
5. 解释 

享元接口 Flyweight 定义了一个 display 方法，接受一个字符和外部状态。
具体享元类 CharacterFlyweight 实现了 Flyweight 接口，持有字符数据，并在 display 方法中显示字符和外部状态。
享元工厂 FlyweightFactory 使用一个 Map 来缓存和管理字符对象。通过 getFlyweight 方法获取共享的对象。
客户端代码 创建享元工厂实例，获取共享的字符对象，并调用 display 方法显示字符和其外部状态。
通过这种方式，享元模式帮助我们管理和复用大量的字符对象，从而提高内存利用率和性能。


## 带外部状态的享元模式

带外部状态的享元模式是一种结构型设计模式，它通过共享尽可能多的对象来减少内存使用，从而提高性能。这种模式特别适用于大量细粒度对象的场景，比如图形界面元素、字符、或其他重复出现的对象。

在享元模式中，内部状态是由享元对象自己管理的，它是可共享的；而外部状态则由客户端管理，它是不可共享的，并且通常与具体的使用场景相关。带外部状态的享元模式就是在共享对象的同时，通过引入外部状态来处理变化的需求。

以下是带外部状态的享元模式的关键组件：

1. Flyweight（享元）: 定义一个接口或抽象类，用于操作内部状态。 
2. ConcreteFlyweight（具体享元）: 实现Flyweight接口，负责存储和操作内部状态。 
3. UnsharedConcreteFlyweight（不可共享享元）: 通常用于定义那些不需要共享的享元对象。 
4. FlyweightFactory（享元工厂）: 用于创建和管理享元对象，确保享元对象可以被共享。 
5. Client（客户端）: 维护外部状态，并在享元对象上调用相应的方法。

优点
1. 减少内存使用: 通过共享对象来减少内存消耗。 
2. 性能提升: 减少对象的创建和销毁，提升系统性能。
缺点
1. 实现复杂: 需要管理内部状态和外部状态的分离，增加了系统的复杂度。 
2. 不适用于状态差异过大的场景: 如果对象的外部状态变化太大，共享的效果会下降，反而可能增加复杂度。 
3. 这种模式在图形界面系统、文字处理器等需要大量细粒度对象的场景中非常有用

Flyweight 接口定义了享元对象的基本行为。
1. ConcreteFlyweight 类实现了 Flyweight 接口，包含内部状态 intrinsicState。
[FlyWeightExternalState.java](flyWeightWithExternalStatePattern%2FFlyWeightExternalState.java)
2. FlyweightFactory 类管理享元对象的创建和共享，使用 HashMap 存储已创建的享元对象。 
[FlyweightFactory.java](flyWeightWithExternalStatePattern%2FFlyweightFactory.java)
3. Client 类演示了如何使用享元对象，调用工厂方法获取享元对象，并传递外部状态。
[Client.java](flyWeightWithExternalStatePattern%2FClient.java)
这种实现方式保证了享元对象的共享，且通过工厂方法来管理对象的创建和缓存，避免了内存的浪费和性能问题。

## 练习

Sunny软件公司欲开发一个多功能文档编辑器，在文本文档中可以插入图片、动画、视频等多媒体资料。为了节约系统资源，相同的图片、动画和视频在同一个文档中只需保存一份，但是可以多次重复出现，而且它们每次出现时位置和大小均可不同。试使用享元模式设计该文档编辑器。

享元模式（Flyweight Pattern）非常适合这种场景，因为它可以有效地共享相同的对象，减少内存消耗。我们可以将多媒体对象（图片、动画、视频）作为享元对象，将它们的具体位置和大小作为外部状态存储。以下是一个简单的设计思路和示例代码：

享元模式的设计思路
1. Flyweight（享元接口）：定义多媒体对象的接口。 
2. ConcreteFlyweight（具体享元类）：实现享元接口，包含多媒体对象的共享部分（如文件路径）。 
3. FlyweightFactory（享元工厂类）：创建并管理享元对象，确保相同的多媒体对象只创建一次。 
4. UnsharedConcreteFlyweight（非共享具体享元类）：存储多媒体对象的非共享部分（如位置和大小）。 
5. Client（客户端类）：使用享元对象。

