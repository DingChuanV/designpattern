# 外观模式

在软件开发中，有时候为了完成一项较为复杂的功能，一个类需要和多个其他业务类交互，而这些需要交互的业务类经常会作为一个完整的整体出现，由于涉及的类比较多，导致使用时代码较为复杂。

此时，特别需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而使用这些业务类的类只需和该类交互即可。外观模式通过引入一个新的外观类来实现该功能。

外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。

外观模式（Facade Pattern）是一种结构型设计模式，它为一个复杂子系统提供一个更高级别的接口，使得子系统更容易使用。外观模式通过创建一个简化的接口，来隐藏子系统的复杂性，从而提高系统的可用性和可维护性。

外观模式的主要特点

1. 简化接口：外观模式提供一个统一的接口，简化了客户端对子系统的使用。
2. 松散耦合：通过引入外观类，客户端与子系统的具体实现解耦，减少了代码的依赖性。
3. 增强可维护性：子系统的复杂性被封装在外观类中，修改子系统时不影响客户端代码。

外观模式的结构
外观模式主要包括以下角色：

1. Facade（外观类）：提供一个高层接口，使得客户端能够更容易地使用子系统。
2. Subsystem classes（子系统类）：实现子系统的功能，处理实际的业务逻辑。外观类会调用这些类的方法来完成工作。

适用场景
外观模式适用于以下场景：

1. 简化复杂子系统的使用：当系统包含多个复杂子系统时，可以使用外观模式提供一个简单的接口。
2. 松散耦合：需要降低客户端与多个子系统之间的耦合度时，可以使用外观模式。
3. 多层结构：在多层结构的系统中，可以使用外观模式来定义每一层的接口，便于层与层之间的交互。
4. 通过使用外观模式，可以提高代码的可读性和可维护性，使得客户端能够更容易地使用和操作复杂的子系统。

假设我们有一个家庭影院系统，包括DVD播放器、投影仪、音响等组件。

我们可以使用外观模式来简化家庭影院的操作：

[subSystem](subsystem)
[Client.java](Client.java)
[HomeTheaterFacade.java](HomeTheaterFacade.java)

抽象外观类的引入
[abstractFacadePattern](abstractfacadepattern)
优点
1. 灵活性：通过使用抽象外观类，可以轻松地扩展和修改具体外观类的行为，而无需修改客户端代码。 
2. 可扩展性：可以创建多个具体外观类，针对不同的子系统实现不同的功能，满足不同的需求。 
3. 通过引入抽象外观类，外观模式变得更加灵活和可扩展，适应性更强。



练习

Sunny软件公司为新开发的智能手机控制与管理软件提供了一键备份功能。通过该功能可以将原本存储在手机中的通讯录、短信、照片、歌曲等资料一次性地全部复制到移动存储介质（如MMC卡或SD卡）中。

在实现过程中需要与多个已有的类进行交互，例如通讯录管理类、短信管理类等。为了降低系统的耦合性，试使用外观模式来设计并实现该一键备份功能


为了实现一键备份功能，并降低系统的耦合性，我们可以使用外观模式。以下是详细的设计步骤和代码实现：

1. 定义子系统类
   首先，我们定义几个子系统类，分别处理通讯录管理、短信管理、照片管理和歌曲管理等功能。

2. 创建外观类
      然后，创建一个外观类 BackupFacade，它封装所有子系统的功能，提供一个简单的接口来进行一键备份。


3. 客户端代码
      最后，在客户端代码中使用外观类 BackupFacade 来执行一键备份功能：
