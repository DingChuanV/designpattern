# 代理模式

代理模式是一种应用很广泛的结构型设计模式，而且变化很多。在代理模式中引入了一个新的代理对象，代理对象可以在客户端对象和目标对象之间起到中介的作用，去掉客户不能看到的内容和服务或者增添客户需要的额外服务。

代理模式定义如下：代理模式（Proxy Pattern）：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。

代理模式是一种对象结构型模式。代理模式的结构比较简单，其核心是代理类。为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层。

在代理模式结构图中包含以下3个角色。

1. Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，使得在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。
2. Proxy（代理主题角色）​：代理主题角色内部包含了对真实主题的引用，从而可以在任何时候操作真实主题对象。在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题。代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。
3. RealSubject（真实主题角色）​：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。代理模式的结构图比较简单，但是在真实的使用和实现过程中要复杂很多，特别是代理类的设计和实现。

在实际开发过程中，代理类的实现比上述代码要复杂很多。代理模式根据其目的和实现方式不同可分为很多种类，其中常用的几种代理模式简要说明如下。

1. 远程代理（Remote Proxy）：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中。远程代理又称为大使（Ambassador）​。
2. 虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。
3. 保护代理（Protect Proxy）：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。
4. 缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。
5. 智能引用代理（Smart Reference Proxy）：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。

在这些常用的代理模式中，有些代理类的设计非常复杂。例如远程代理类，它封装了底层网络通信和对远程对象的调用，其实现较为复杂。


## 远程代理

远程代理是一种常用的代理模式，它使得客户端程序可以访问在远程主机（或另一个虚拟机）上的对象。远程主机可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是局域的而不是远程的，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。

客户端对象不能直接访问远程主机中的业务对象，只能采取间接访问的方式。远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，它对于客户端对象而言是透明的。客户端无须关心实现具体业务的是谁，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可

在Java语言中，可以通过RMI（Remote Method Invocation，远程方法调用）机制来实现远程代理，它能够实现一个Java虚拟机中的对象调用另一个Java虚拟机中对象的方法。在RMI中，客户端对象可以通过一个桩（Stub）对象与远程主机上的业务对象进行通信。由于桩对象和远程业务对象接口一致，因此对于客户端而言，操作远程对象和本地桩对象没有任何区别，桩对象就是远程业务对象在本地主机的代理对象。


在RMI实现过程中，远程主机端有一个Skeleton（骨架）对象来负责与Stub对象通信，RMI的基本实现步骤如下：
1. 客户端发起请求，将请求转交至RMI客户端的Stub类。
2. Stub类将请求的接口、方法、参数等信息进行序列化。
3. 将序列化后的流使用Socket传输至服务器端。
4. 服务器端接收到流后将其转发至相应的Skeleton类。
5. Skeleton类将请求信息反序列化后调用实际的业务处理类。
6. 业务处理类处理完毕后将结果返回给Skeleton类。
7. Skeleton类将结果序列化，再次通过Socket将流传送给客户端的Stub。
8. Stub在接收到流后进行反序列化，将反序列化后得到的Java Object对象返回给客户端调用者。

至此，一次完整的远程方法调用得以完成。

[remoteproxy](remoteproxy)

远程代理的应用：
1. 远程服务调用：客户端需要访问位于远程服务器上的服务或对象
2. 分布式系统： 在分布式架构中，需要通过网络访问分布式在不同节点上的对象
3. 性能优化：通过代理对象减少网络通信次数，提高性能

远程代理模式有效地将网络通信的细节隐藏起来，使得客户端无需关心对象的实际位置，从而简化了客户端代码的编写。

