# 代理模式

代理模式是一种应用很广泛的结构型设计模式，而且变化很多。在代理模式中引入了一个新的代理对象，代理对象可以在客户端对象和目标对象之间起到中介的作用，去掉客户不能看到的内容和服务或者增添客户需要的额外服务。

代理模式定义如下：代理模式（Proxy Pattern）：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。

代理模式是一种对象结构型模式。代理模式的结构比较简单，其核心是代理类。为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层。

在代理模式结构图中包含以下3个角色。

1. Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，使得在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。
2. Proxy（代理主题角色）​：代理主题角色内部包含了对真实主题的引用，从而可以在任何时候操作真实主题对象。在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题。代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。
3. RealSubject（真实主题角色）​：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。代理模式的结构图比较简单，但是在真实的使用和实现过程中要复杂很多，特别是代理类的设计和实现。

在实际开发过程中，代理类的实现比上述代码要复杂很多。代理模式根据其目的和实现方式不同可分为很多种类，其中常用的几种代理模式简要说明如下。

1. 远程代理（Remote Proxy）：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中。远程代理又称为大使（Ambassador）​。
2. 虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。
3. 保护代理（Protect Proxy）：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。
4. 缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。
5. 智能引用代理（Smart Reference Proxy）：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。

在这些常用的代理模式中，有些代理类的设计非常复杂。例如远程代理类，它封装了底层网络通信和对远程对象的调用，其实现较为复杂。

## 静态代理

静态代理是指在编译期间就已经确定了代理类和真实类的关系，代理类在编译时就确定了要代理的真实对象。

下面是一个简单的示例，演示如何使用静态代理模式来实现对邮件发送的控制和额外功能的增加。
[staticproxy](staticproxy)

## 远程代理

远程代理是一种常用的代理模式，它使得客户端程序可以访问在远程主机（或另一个虚拟机）上的对象。远程主机可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是局域的而不是远程的，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。

客户端对象不能直接访问远程主机中的业务对象，只能采取间接访问的方式。远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，它对于客户端对象而言是透明的。客户端无须关心实现具体业务的是谁，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可

在Java语言中，可以通过RMI（Remote Method Invocation，远程方法调用）机制来实现远程代理，它能够实现一个Java虚拟机中的对象调用另一个Java虚拟机中对象的方法。在RMI中，客户端对象可以通过一个桩（Stub）对象与远程主机上的业务对象进行通信。由于桩对象和远程业务对象接口一致，因此对于客户端而言，操作远程对象和本地桩对象没有任何区别，桩对象就是远程业务对象在本地主机的代理对象。


在RMI实现过程中，远程主机端有一个Skeleton（骨架）对象来负责与Stub对象通信，RMI的基本实现步骤如下：
1. 客户端发起请求，将请求转交至RMI客户端的Stub类。
2. Stub类将请求的接口、方法、参数等信息进行序列化。
3. 将序列化后的流使用Socket传输至服务器端。
4. 服务器端接收到流后将其转发至相应的Skeleton类。
5. Skeleton类将请求信息反序列化后调用实际的业务处理类。
6. 业务处理类处理完毕后将结果返回给Skeleton类。
7. Skeleton类将结果序列化，再次通过Socket将流传送给客户端的Stub。
8. Stub在接收到流后进行反序列化，将反序列化后得到的Java Object对象返回给客户端调用者。

至此，一次完整的远程方法调用得以完成。

[remoteproxy](remoteproxy)

远程代理的应用：
1. 远程服务调用：客户端需要访问位于远程服务器上的服务或对象
2. 分布式系统： 在分布式架构中，需要通过网络访问分布式在不同节点上的对象
3. 性能优化：通过代理对象减少网络通信次数，提高性能

远程代理模式有效地将网络通信的细节隐藏起来，使得客户端无需关心对象的实际位置，从而简化了客户端代码的编写。

## 虚拟代理
虚拟代理是一种设计模式，通过在实际对象的前面放置一个代理对象来延迟对象的初始化或者减少实际对象的资源消耗。虚拟代理在需要时才创建真实对象，可以提升程序的性能和响应速度。

虚拟代理也是一种常用的代理模式。对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。

在以下两种情况下可以考虑使用虚拟代理：
1. 由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象。通常在实现时可以结合多线程技术，一个线程用于显示代理对象，其他线程用于加载真实对象。这种虚拟代理模式可以应用在程序启动的时候，由于创建代理对象在时间和处理复杂度上要少于创建真实对象，因此，在程序启动时，可以用代理对象代替真实对象初始化，大大加速系统的启动时间。当需要使用真实对象时，再通过代理对象来引用，而此时真实对象可能已经成功加载完毕，可以缩短用户的等待时间
2. 当一个对象的加载十分耗费系统资源的时候，也非常适合使用虚拟代理。虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象，再通过代理对象来引用真实对象。为了节省内存，在第一次引用真实对象时再创建对象，并且该对象可被多次重用，在以后每次访问时需要检测所需对象是否已经被创建，因此在访问该对象时需要进行存在性检测，这需要消耗一定的系统时间，但是可以节省内存空间，这是一种用时间换取空间的做法。

当实现虚拟代理时，可以选择一个更贴近实际场景的例子，比如一个简单的图片加载器。在这个示例中，我们将创建一个虚拟代理来延迟图片的加载，以便在需要时才真正加载图片。
[virtualpattern](virtualpattern)

## Java动态代理

通常情况下，每个代理类编译之后都会生成一个class文件，代理类所实现的接口和所代理的方法都被固定，这种代理被称为静态代理（Static Proxy）​。那么有没有一种机制能够让系统在运行时动态创建代理类？答案就是本节将要介绍的动态代理（Dynamic Proxy）。动态代理是一种较为高级的代理模式，它在事务管理、AOP（Aspect-Oriented Programming，面向方面编程）等领域都发挥了重要的作用。